public class Ex3_4 {

	public static void main(String[] args) {
		// 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는것
		// (타입)피연산자
				
		double d = 85.4;
		int score = (int)d;
		// -> d의 값인 85.4를 그대로 가져와서 int형태로 변환한거라 d의 변수값이 변한게 아님!
				
		// float을 int로 변환할때 정수는 소수점을 가질수없으므로 버림처리됨. 반올림X
				
		// 자동형변환(컴파일러가 자동형변환해줌)
		float f = 1234; // int값을 float타입 변수에 저장
		// float 범위가 더 커서 문제 없음, 형변환을 안쓴게아니라 컴파일러가 넣어준거임
		// 원래는 대입연산자의 양쪽 타입이 맍아야함.
				
		// int i = 3.14f; 는 에러 -> 범위가 더 작은 int에 float을 넣었기때문
		// 3.14가 int 3이되면서 값손실 발생 == 컴파일러가 자동형변환 못해줌
		// 직접 앞에 (int)로 수동형변환
				
		// 자동형변환 EX
		// 작은값을 큰값에 담을때(값손실없음)는 컴파일러가 자동형변환
		// byte -> int는 형변환 생략가능, int -> byte는 생략 불가능
		// 큰값을 작은타입은 변수에 넣을때 주의하기!
				
		// 형변환 정리!
		// 형변환을 생략하면 기존의값을 최대한 보존할수있는 타입으로 컴파일러가 알아서 자동형변환을 한다.
		// 그래서 표현범위가 좁은 타입에서 넓은 타입으로형변환하는 경우에는 값 손실이 없으므로
		// 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
				
		// 컴파일러는 값손실이 없을때만 자동형변환을 해주고 그 외에는 수동형변환을 해줘야함.
				
		// int(1byte) -> short/char(2byte) -> int(4byte) -> long(8byte) -> float(4byte) -> douible(8byte)
				
				
		byte b = 100; // int를 더 작은 byte에 넣어도 문제없는 이유는 byte타입의 범위(-128~!27)값이기 때문
		// 컴파일러가 100을 byte로 자동 형변환함(형변환해도 값손실이 없으니까), 예외적 상황
				
		// int i = 100;  /  byte b = i; 는 오류
		// 왜냐 위에서는 100이 리터럴 즉, 상수라서 컴파일러가 값이100이란걸 명확히 아는데
		// 여기서는 i라는 변수라 안에 무슨값이 들었는지 컴파일러가 확신을못해서(값손실이날지 안날지) 에러! -> 수동형변환 해야함
				
		//byte b = 1000; 에러! ->  byte b = (byte)1000; 에러는 안나지만 값손실이 발생해 변수 b에 -24rk wjwkdehla
				
	}

}
