
public class Ex3_1 {

	public static void main(String[] args) {
		
		// 연산자 : 연산을 수행하는 기호, 모든 연산자는 연산결과를 반환한다.
		// 피연산자 : 연산자의 연산 수행 대상
		
		// 산술연산자, 비교연산자, 논리연산자, 대입연산자, 기타(형변환, 삼항(?:), instanceof)
		
		// 우선순위
		// 단항(피연산자1개) > 산술 > 비교 > 논리 > 삼항 > 대입
		
		// 연산자의 결합규칙
		// 우선순위가 같은경우 왼쪽 -> 오른쪽 (대입, 단항 제외 / 오른쪾 -> 왼쪽)
		
		// 연산자의 우선순위와 결합법칙 정리
		// 1. 산술 > 비교 > 논리 > 대입 - 대입은 제일 마지막에 수행된다.
		// 2. 단항 > 이항 > 삼항 - 단항 연산자의 우선순위가 이항 연산자보다 높다.
		// 3. 단항 연산자와 대입 연산자를 제외한 모은 연산의 진행방향은 왼쪽에서 오른쪽이다.
		
		// 증감연산자
		
		// 증가 연산자 ++
		// 전위형 ++i; - 값이 먼저 증가(값이 참조되기전에)
		// 후위형 i++; - 값이 나중에 증가(값이 참조된후에)
		
		// ex) j = ++i; --> ==  ++i;  -->  j=i; 전위형
		//     j = i++; --> ==  j=i;  -->  i++; 후위형
		
		// -> 증감연산자가 독립적으로 사용될때는 전위형 후위형의 차이가 없음.
		
		// 부호연산자 (-, +)
		// 단항연산자임임
		// - 는 피연산자의 부호를 반대로 변경, +는 실제로 사용 X
		
		
		// ----------------------------------------------------
		
		
		// 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는것
		// (타입)피연산자
		
		double d = 85.4;
		int score = (int)d;
		// -> d의 값인 85.4를 그대로 가져와서 int형태로 변환한거라 d의 변수값이 변한게 아님!
		
		// float을 int로 변환할때 정수는 소수점을 가질수없으므로 버림처리됨. 반올림X
		
		// 자동형변환(컴파일러가 자동형변환해줌)
		float f = 1234; // int값을 float타입 변수에 저장
		// float 범위가 더 커서 문제 없음, 형변환을 안쓴게아니라 컴파일러가 넣어준거임
		// 원래는 대입연산자의 양쪽 타입이 맍아야함.
		
		// int i = 3.14f; 는 에러 -> 범위가 더 작은 int에 float을 넣었기때문
		// 3.14가 int 3이되면서 값손실 발생 == 컴파일러가 자동형변환 못해줌
		// 직접 앞에 (int)로 수동형변환
		
		// 자동형변환 EX
		// 작은값을 큰값에 담을때(값손실없음)는 컴파일러가 자동형변환
		// byte -> int는 형변환 생략가능, int -> byte는 생략 불가능
		// 큰값을 작은타입은 변수에 넣을때 주의하기!
		
		// 형변환 정리!
		// 형변환을 생략하면 기존의값을 최대한 보존할수있는 타입으로 컴파일러가 알아서 자동형변환을 한다.
		// 그래서 표현범위가 좁은 타입에서 넓은 타입으로형변환하는 경우에는 값 손실이 없으므로
		// 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
		
		// 컴파일러는 값손실이 없을때만 자동형변환을 해주고 그 외에는 수동형변환을 해줘야함.
		
		// int(1byte) -> short/char(2byte) -> int(4byte) -> long(8byte) -> float(4byte) -> douible(8byte)
		
		
		byte b = 100; // int를 더 작은 byte에 넣어도 문제없는 이유는 byte타입의 범위(-128~!27)값이기 때문
		// 컴파일러가 100을 byte로 자동 형변환함(형변환해도 값손실이 없으니까), 예외적 상황
		
		// int i = 100;  /  byte b = i; 는 오류
		// 왜냐 위에서는 100이 리터럴 즉, 상수라서 컴파일러가 값이100이란걸 명확히 아는데
		// 여기서는 i라는 변수라 안에 무슨값이 들었는지 컴파일러가 확신을못해서(값손실이날지 안날지) 에러! -> 수동형변환 해야함
		
		//byte b = 1000; 에러! ->  byte b = (byte)1000; 에러는 안나지만 값손실이 발생해 변수 b에 -24rk wjwkdehla
		
		
		// ----------------------------------------------------
		
		
		// 사칙연산자 + - * /
		// 컴퓨터는 같은 타입끼리만 결과할수있고 결과값의 타입도 같음
		
		// 산술변환 : 연산전에 피연산자의 타입을 일치시키는것
		// 규칙 1. 두 피연산자의 타입을 같게 일치시킨다 (보다 큰 타입으로 일치)
		// 규칙 2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다(byte, char, short)
		
		// '2' 문자 2에서 -0을 하면 유니코드에따라 50 - 48 이므로 2
		// 앞에서 문자를 숫자로 변환하려면 - 0 을 해야한다고 했던 이유이기도함.
		
		// 예제
		int a = 1_000_000; // 1백만 = 10의 6제곱
		int a2 = 2_000_000; // 2백만 = 10의 6제곱
		
		// 10의 12제곱 (int의 범위는 10의9제곱)
		long c = a * a2;
		
		System.out.println(c); // -1454759936 왜 음수...? == 오버플로우 발생
		// int * int라 값이 int로 나온거
		// 해결방법 : long c = (long)a $ a2; a나 a2를 형변환해줌
		
		
		// ----------------------------------------------------
		
		// Math.round()
		// 실수를 소수점 첫째자리에서 반올림한 정수를 반환
		// Math 수학과 관련된 메소드를 가지고있는 클래스
		long result = Math.round(4.52); // 5
		
		// 원하는 자리에서 반올림하려면 10의 n제곱으로 곱해서 반올림한뒤 다시 나눠야함
		// 예제 
		double pi =3.141592;
		double shortPi = Math.round(pi * 1000) / 1000.0; // 네번째인 5에서 반올림하고싶다
		
		// 풀어보자면
		// Math.round(pi * 1000) / 1000.0 --> pi == 3141.592
		// Math.round(3141.592) / 1000.0 --> Math.round()는 첫째자리에서 반올림하니까
		// 3142 / 1000.0 == 3.142
		// 만약 1000.0이 아니라 1000으로 나누면 int / int니까 3이 결과값
		
		// 3.141을 얻으려면? 반올림이 아니라 잘라내려면?
		System.out.println((int)(pi*1000)); // 3141
		System.out.println((int)(pi*1000) / 1000.0);
		
		
		// 나머지 연산자 % : 오른쪽 피연산자로 나누고 남은 나머지를 반환
		//				  나누는 피연산자는 0이아닌 정수만 허용(부호는 무시됨)
		// 10/8 = 1, 10%8 = 2 -> 몫은1 나머지는2
		
		
		// ----------------------------------------------------
		
		// 비교연산자 > < >= <= == !=
		// 두 피연산자를 비교해서 true 또는 false를 반환
		// ex) 'A' > 'B' 의 경우 산술변환규칙에 의해 integer보다 작으므로 int로 변환됨
		//     따라서 65 > 66 이니까 false
		
		// 문자열 비교에는 == 대신 equals()를 사용해야 한다!
		
		// 문자열을 만드는 1번방법
		// ex) String str1 = "abc";  / String str2 = "abc";
		//     str1==str2 / st1.equals(str2) -> 모두 true
		
		// 문자열을 만드는 2번 방법
		// 하지만 내용이 같은데도 String str1 = new String("abc");  / String str2 = new String("abc"); 이렇게 해주면
		// tr1==str2 -> false / st1.equals(str2) ->true
		
		// 문자열을 만드는 방법 2가지에 대한 차이는 9장, 2번방법은 6장에서 배울거임 
		
		// -------------------------------------------------
		
		// 논리 연산자 $$ ||
		// 조건식을 연결할 때 사용ㅇ하는 연산자
		// || (OR결합) : 피연산중 어느 한쪽이 true이면 결과는 true
		// && (AND결합) : 피연산자 양쪽 모두 true여야 결과가 true
		
		// ex) x > 10 && x < 20 == 10 < x && x < 20
		// 2의배수 == 변수%2==0  / 3의베수 == 변수%3==0
		
		// 한식에 and, or이 들어가면 ()로 우선순위를 지정
		// and가 우선순위가 더 높음
		
		// ex) 문자 ch는 숫자 '0'~'9'이다
		// -> 사용자로부터 입력된 문자가 숫자('0'~'9'인지 확인하는식)
		// -> '0' <= ch && ch <= '9'
		// '0'~'9' == 48~57
		
		// ex) 문자 ch는 대문자 또는 소문자이다
		// -> ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')
		
		// 논리 부정 연산자 !
		// true를 false로 flase를 true로 바꾼다
		
		boolean b2 = true;
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}

}
